#include <stdio.h>
#include <gmp.h>
#include <time.h> // Include time.h for timing functions and seeding the random number generator
#include "cifer/innerprod/simple/ddh.h"
#include "cifer/data/vec.h"

//2015经典DDH的FE，算法详见论文分享24-7-17 P4

// Function to free master keys
void cfe_ddh_master_keys_free(cfe_vec *msk, cfe_vec *mpk) {
    cfe_vec_frees(msk, mpk, NULL);
}

int main() {
    // Initialize the random number generator manually
    gmp_randstate_t rstate;
    gmp_randinit_mt(rstate);
    unsigned long int seed = time(NULL);
    gmp_randseed_ui(rstate, seed);

    // Define parameters for the scheme
    size_t l = 10; // dimension of encryption vector
    mpz_t bound, fe_key, xy, el;
    mpz_inits(bound, fe_key, xy, el, NULL);
    mpz_set_ui(bound, 2);
    mpz_pow_ui(bound, bound, 14); // bound of the input values set to 2^14
    size_t modulus_len = 1024; // bit length of prime modulus p (using precomputed keys)

    // Instantiate the scheme using precomputed initialization
    cfe_ddh s, encryptor, decryptor;
    cfe_error err = cfe_ddh_precomp_init(&s, l, modulus_len, bound);
   //cfe_error err = cfe_ddh_init(&s, l, modulus_len, bound);  不使用预设密钥
    if (err != CFE_ERR_NONE) {
        fprintf(stderr, "Error initializing DDH scheme\n");
        return 1;
    }

    // Generate master keys (secret and public)
    cfe_vec msk, mpk, ciphertext, x, y;
    cfe_ddh_master_keys_init(&msk, &mpk, &s);
    cfe_ddh_generate_master_keys(&msk, &mpk, &s); // This function returns void

    // Randomly generate target vector y within [0, bound)
    cfe_vec_init(&y, l);
    for (size_t i = 0; i < l; ++i) {
        mpz_t tmp;
        mpz_init(tmp);
        mpz_urandomm(tmp, rstate, bound); // Use mpz_urandomm to generate a random number in [0, bound)
        cfe_vec_set(&y, tmp, i);
        mpz_clear(tmp);
    }

    // Print the randomly generated vector y
    printf("Randomly generated vector y: [");
    for (size_t i = 0; i < l; ++i) {
        mpz_t val;
        mpz_init(val);
        cfe_vec_get(val, &y, i);
        gmp_printf("%Zd", val);
        if (i < l - 1) {
            printf(", ");
        }
        mpz_clear(val);
    }
    printf("]\n");

    // Derive functional encryption key for y
    err = cfe_ddh_derive_fe_key(fe_key, &s, &msk, &y);
    if (err != CFE_ERR_NONE) {
        fprintf(stderr, "Error deriving functional encryption key\n");
        return 1;
    }

    // Simulate instantiation of encryptor
    // Encryptor wants to hide x and should be given master public key by the trusted entity
    cfe_vec_init(&x, l);
    for (size_t i = 0; i < l; ++i) {
        mpz_t tmp;
        mpz_init(tmp);
        mpz_urandomm(tmp, rstate, bound); // Use mpz_urandomm to generate a random number in [0, bound)
        cfe_vec_set(&x, tmp, i);
        mpz_clear(tmp);
    }

    // Print the randomly generated vector x
    printf("Randomly generated vector x: [");
    for (size_t i = 0; i < l; ++i) {
        mpz_t val;
        mpz_init(val);
        cfe_vec_get(val, &x, i);
        gmp_printf("%Zd", val);
        if (i < l - 1) {
            printf(", ");
        }
        mpz_clear(val);
    }
    printf("]\n");

    cfe_ddh_copy(&encryptor, &s);
    cfe_ddh_ciphertext_init(&ciphertext, &encryptor);

    // Measure encryption time
    clock_t start_time = clock();
    err = cfe_ddh_encrypt(&ciphertext, &encryptor, &x, &mpk);
    clock_t end_time = clock();
    double encryption_time = ((double)(end_time - start_time)) / CLOCKS_PER_SEC;

    if (err != CFE_ERR_NONE) {
        fprintf(stderr, "Error encrypting vector x\n");
        return 1;
    }

    // Simulate instantiation of decryptor that decrypts the cipher generated by encryptor
    cfe_ddh_copy(&decryptor, &s);

    // Measure decryption time
    start_time = clock();
    err = cfe_ddh_decrypt(xy, &decryptor, &ciphertext, fe_key, &y);
    end_time = clock();
    double decryption_time = ((double)(end_time - start_time)) / CLOCKS_PER_SEC;

    if (err != CFE_ERR_NONE) {
        fprintf(stderr, "Error decrypting ciphertext\n");
        return 1;
    }

    // Print the result
    gmp_printf("The inner product of the encrypted vector x and vector y is %Zd\n", xy);

    // Print the times
    printf("Encryption time: %.6f seconds\n", encryption_time);
    printf("Decryption time: %.6f seconds\n", decryption_time);

    // Free memory
    cfe_vec_free(&x);
    cfe_vec_free(&y);
    cfe_vec_free(&ciphertext);
    cfe_ddh_free(&s);
    cfe_ddh_free(&encryptor);
    cfe_ddh_free(&decryptor);
    cfe_ddh_master_keys_free(&msk, &mpk);
    mpz_clears(bound, fe_key, xy, el, NULL);

    // Clear the random state
    gmp_randclear(rstate);

    return 0;
}